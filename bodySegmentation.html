<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Segmentation Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
        }

        input[type="file"] {
            padding: 10px 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        table {
            margin: 20px auto;
            border-collapse: collapse;
            width: 80%;
            text-align: center;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        th {
            background-color: #f4f4f4;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        tr:hover {
            background-color: #f1f1f1;
        }
    </style>
</head>

<body>
    <h1>Image Segmentation Analysis</h1>
    <input type="file" id="imageUpload" accept="image/*" multiple>
    
    <table>
        <thead>
            <tr>
                <th>File Name</th>
                <th>Brightness (Person)</th>
                <th>Sharpness (Person)</th>
                <th>Brightness (Background)</th>
                <th>Sharpness (Background)</th>
            </tr>
        </thead>
        <tbody id="resultTableBody"></tbody>
    </table>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const resultTableBody = document.getElementById('resultTableBody');

        const selfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`,
        });

        selfieSegmentation.setOptions({
            modelSelection: 1,
        });
        selfieSegmentation.onResults(onResults);

        imageUpload.addEventListener('change', async (event) => {
            const files = event.target.files;
            for (const file of files) {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    const originalCanvas = createCanvas(480, 360);
                    const originalCtx = originalCanvas.getContext('2d');
                    originalCtx.drawImage(img, 0, 0, 480, 360);
                    selfieSegmentation.send({ image: originalCanvas }).then(() => {
                        img.fileName = file.name;
                    });
                };
            }
        });

        function onResults(results) {
            const personCanvas = createCanvas(480, 360);
            const backgroundCanvas = createCanvas(480, 360);
            const personCtx = personCanvas.getContext('2d');
            const backgroundCtx = backgroundCanvas.getContext('2d');

            personCtx.drawImage(results.segmentationMask, 0, 0, personCanvas.width, personCanvas.height);
            personCtx.globalCompositeOperation = 'source-in';
            personCtx.drawImage(results.image, 0, 0, 480, 360);
            personCtx.globalCompositeOperation = 'source-over';

            backgroundCtx.drawImage(results.segmentationMask, 0, 0, backgroundCanvas.width, backgroundCanvas.height);
            backgroundCtx.globalCompositeOperation = 'source-out';
            backgroundCtx.drawImage(results.image, 0, 0, 480, 360);
            backgroundCtx.globalCompositeOperation = 'source-over';

            const personBrightness = calculateBrightness(personCtx, 480, 360);
            const personSharpness = calculateFocusScore(personCtx, 480, 360);
            const backgroundBrightness = calculateBrightness(backgroundCtx, 480, 360);
            const backgroundSharpness = calculateFocusScore(backgroundCtx, 480, 360);

            addResultToTable(results.image.fileName, personBrightness, personSharpness, backgroundBrightness, backgroundSharpness);
        }

        function createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        }

        function calculateBrightness(context, width, height) {
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;

            let totalIntensity = 0;
            let count = 0;

            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                totalIntensity += gray;
                count++;
            }

            return totalIntensity / count;
        }

        function calculateFocusScore(context, width, height) {
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;
            const grayscale = [];

            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                grayscale.push(gray);
            }

            const laplacianKernel = [
                [0, 1, 0],
                [1, -4, 1],
                [0, 1, 0],
            ];
            const result = new Array(grayscale.length).fill(0);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let sum = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = grayscale[(y + ky) * width + (x + kx)];
                            const weight = laplacianKernel[ky + 1][kx + 1];
                            sum += pixel * weight;
                        }
                    }
                    result[y * width + x] = sum;
                }
            }

            return calculateVariance(result);
        }

        function calculateVariance(data) {
            const validData = data.filter((value) => !isNaN(value));
            const mean = validData.reduce((sum, val) => sum + val, 0) / validData.length;
            return validData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / validData.length;
        }

        function addResultToTable(fileName, personBrightness, personSharpness, backgroundBrightness, backgroundSharpness) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${fileName}</td>
                <td>${personBrightness.toFixed(2)}</td>
                <td>${personSharpness.toFixed(2)}</td>
                <td>${backgroundBrightness.toFixed(2)}</td>
                <td>${backgroundSharpness.toFixed(2)}</td>
            `;
            resultTableBody.appendChild(row);
        }
    </script>
</body>
</html>
