<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Face Crop, Brightness & Sharpness</title>
  <style>
    canvas {
      border: 1px solid black;
      margin: 10px;
    }
    #info {
      font-family: Arial, sans-serif;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Face Crop, Brightness, and Sharpness Detection</h1>
  <input type="file" id="uploadImage" accept="image/*">
  <div>
    <canvas id="originalCanvas"></canvas>
    <p id="originalBrightness">Brightness: --, Sharpness: --</p>
  </div>
  <div>
    <canvas id="croppedCanvas"></canvas>
    <p id="croppedBrightness">Brightness: --, Sharpness: --</p>
  </div>
  <div>
    <canvas id="remainingCanvas"></canvas>
    <p id="remainingBrightness">Brightness: --, Sharpness: --</p>
  </div>

  <script>
    const uploadInput = document.getElementById("uploadImage");
    const originalCanvas = document.getElementById("originalCanvas");
    const croppedCanvas = document.getElementById("croppedCanvas");
    const remainingCanvas = document.getElementById("remainingCanvas");
    const originalCtx = originalCanvas.getContext("2d");
    const croppedCtx = croppedCanvas.getContext("2d");
    const remainingCtx = remainingCanvas.getContext("2d");

    uploadInput.addEventListener("change", async (event) => {
      const file = event.target.files[0];
      if (file) {
        const image = new Image();
        image.src = URL.createObjectURL(file);
        image.onload = async () => {
          originalCanvas.width = image.width;
          originalCanvas.height = image.height;
          originalCtx.drawImage(image, 0, 0);

          // Use Mediapipe or other libraries to detect face landmarks
          const faceLandmarks = await detectFaceLandmarks(image);
          processFace(faceLandmarks);
        };
      }
    });

    async function detectFaceLandmarks(image) {
      // Use Mediapipe Face Detection or your preferred face detection library
      const faceLandmarks = {
        landmarks: [
          { x: 0.47, y: 0.4 },
          { x: 0.57, y: 0.6 },
          // Add more landmarks as needed
        ],
      };
      return faceLandmarks;
    }

    function processFace(results) {
      if (results && results.landmarks) {
        const face = results;
        const landmarks = face.landmarks;

        const paddingX = 30;
        const paddingY = 40;

        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
        for (const landmark of landmarks) {
          const x = landmark.x * originalCanvas.width;
          const y = landmark.y * originalCanvas.height;
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }

        minX = Math.max(minX - paddingX, 0);
        minY = Math.max(minY - paddingY, 0);
        maxX = Math.min(maxX + paddingX, originalCanvas.width);
        maxY = Math.min(maxY + paddingY, originalCanvas.height);

        const cropWidth = maxX - minX;
        const cropHeight = maxY - minY;

        croppedCanvas.width = cropWidth;
        croppedCanvas.height = cropHeight;

        if (cropWidth > 0 && cropHeight > 0) {
          const croppedImageData = originalCtx.getImageData(minX, minY, cropWidth, cropHeight);
          croppedCtx.putImageData(croppedImageData, 0, 0);
        }

        remainingCanvas.width = originalCanvas.width;
        remainingCanvas.height = originalCanvas.height;
        remainingCtx.drawImage(originalCanvas, 0, 0);
        remainingCtx.clearRect(minX, minY, cropWidth, cropHeight);

        const croppedBrightness = calculateBrightness(croppedCtx, cropWidth, cropHeight);
        const croppedSharpness = calculateFocusScore(croppedCtx, cropWidth, cropHeight);
        document.getElementById("croppedBrightness").textContent = `Brightness: ${croppedBrightness.toFixed(2)}, Sharpness: ${croppedSharpness.toFixed(2)}`;

        const remainingBrightness = calculateBrightness(remainingCtx, originalCanvas.width, originalCanvas.height);
        const remainingSharpness = calculateFocusScore(remainingCtx, originalCanvas.width, originalCanvas.height);
        document.getElementById("remainingBrightness").textContent = `Brightness: ${remainingBrightness.toFixed(2)}, Sharpness: ${remainingSharpness.toFixed(2)}`;

        const originalBrightness = calculateBrightness(originalCtx, originalCanvas.width, originalCanvas.height);
        const originalSharpness = calculateFocusScore(originalCtx, originalCanvas.width, originalCanvas.height);
        document.getElementById("originalBrightness").textContent = `Brightness: ${originalBrightness.toFixed(2)}, Sharpness: ${originalSharpness.toFixed(2)}`;
      } else {
        alert("No face detected in the image.");
      }
    }

    function calculateBrightness(context, width, height) {
      const imageData = context.getImageData(0, 0, width, height);
      const data = imageData.data;
      let totalBrightness = 0;

      for (let i = 0; i < data.length; i += 4) {
        const brightness = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        totalBrightness += brightness;
      }

      return totalBrightness / (width * height);
    }

    function calculateFocusScore(context, width, height) {
      const imageData = context.getImageData(0, 0, width, height);
      const data = imageData.data;
      const grayscale = [];

      for (let i = 0; i < data.length; i += 4) {
        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        grayscale.push(gray);
      }

      const laplacianKernel = [
        [0, 1, 0],
        [1, -4, 1],
        [0, 1, 0],
      ];
      const result = new Array(grayscale.length).fill(0);

      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let sum = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const pixel = grayscale[(y + ky) * width + (x + kx)];
              const weight = laplacianKernel[ky + 1][kx + 1];
              sum += pixel * weight;
            }
          }
          result[y * width + x] = sum;
        }
      }

      const variance = calculateVariance(result);
      return variance;
    }

    function calculateVariance(data) {
      const validData = data.filter((value) => !isNaN(value));
      const mean = validData.reduce((sum, val) => sum + val, 0) / validData.length;
      const variance =
        validData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /
        validData.length;
      return variance;
    }
  </script>
</body>
</html>
